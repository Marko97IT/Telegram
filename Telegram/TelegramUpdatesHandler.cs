// Copyright (c) 2024 Marco Concas. All rights reserved.
// Licensed under the Apache License.

using Microsoft.AspNetCore.Server.Kestrel.Core;
using System.Net;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text.Json;
using Telegram.Configurations;
using Telegram.Enums;
using Telegram.Events;
using Telegram.Helpers;
using Telegram.Types;

namespace Telegram
{
    /// <summary>
    /// Provides a class which is responsible for managing incoming updates from the Telegram bot.
    /// </summary>
    public class TelegramUpdatesHandler : IDisposable
    {
        /// <summary>
        /// A <see cref="bool"/> value that indicate when the webhook is ready to handle incoming updates if <see cref="GetUpdatesWay.Webhook"/> is selected.
        /// </summary>
        public bool WebhookIsReady { get; private set; }
        /// <summary>
        /// The event that will be trigged when an incoming update is available.
        /// </summary>
        public event EventHandler<IncomingUpdateReceivedEventArgs> IncomingUpdateReceived;

        private readonly CancellationTokenSource _cancellationTokenSource;
        private readonly JsonSerializerOptions _jsonSerializerOptions;
        private readonly TelegramClient _telegramClient;
        private readonly WebhookConfiguration? _webhookConfiguration;
        private readonly GetUpdatesWay _getUpdatesWay;
        private readonly string _botToken;
        private bool _incomingUpdatesHandling;

        /// <summary>
        /// Initialize a new instance of the <see cref="TelegramUpdatesHandler"/> class.
        /// </summary>
        /// <param name="getUpdatesWay">The way that the incoming updates will be processed.</param>
        /// <param name="botToken">The bot token generated by BotFather.</param>
        /// <param name="webhookConfiguration">The webhook configuration if the way selected is <see cref="GetUpdatesWay.Webhook"/>.</param>
        public TelegramUpdatesHandler(GetUpdatesWay getUpdatesWay, string botToken, WebhookConfiguration? webhookConfiguration = null)
        {
            _cancellationTokenSource = new();
            _jsonSerializerOptions = new() { PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower };
            _telegramClient = new TelegramClient(botToken);
            _webhookConfiguration = webhookConfiguration;
            _getUpdatesWay = getUpdatesWay;
            _botToken = botToken;
        }

        /// <summary>
        /// Start a thread which will handle incoming updates without blocking the main thread.
        /// </summary>
        /// <exception cref="ArgumentNullException"></exception>
        public void StartReceivingUpdates()
        {
            if (!_incomingUpdatesHandling)
            {
                _incomingUpdatesHandling = true;
                new Thread(async () =>
                {
                    await _telegramClient.DeleteWebhookAsync(true);
                    if (_getUpdatesWay == GetUpdatesWay.Polling)
                    {
                        var offset = 0;
                        while (_incomingUpdatesHandling)
                        {
                            try
                            {
                                var updates = await _telegramClient.GetUpdatesAsync(offset, timeout: 300, cancellationToken: _cancellationTokenSource.Token);
                                if (updates != null && updates.Length > 0)
                                {
                                    offset = updates.Select(update => update.UpdateId).Max() + 1;
                                    foreach (var update in updates)
                                    {
                                        IncomingUpdateReceived?.Invoke(this, new IncomingUpdateReceivedEventArgs
                                        {
                                            UpdateReceivedDate = DateTime.UtcNow,
                                            UpdateWay = _getUpdatesWay,
                                            Update = update,
                                        });
                                    }
                                }
                            }
                            catch (TaskCanceledException) { }
                        }
                    }
                    else if (_getUpdatesWay == GetUpdatesWay.Webhook)
                    {
                        if (_webhookConfiguration == null)
                        {
                            throw new ArgumentNullException(nameof(WebhookConfiguration));
                        }

                        if (_webhookConfiguration.HttpsPort < 0 && _webhookConfiguration.HttpsPort > 65535)
                        {
                            throw new InvalidOperationException("The specified HTTPS port is not valid");
                        }

                        using var sslCertificate = GenerateSelfSignedCertificate();
                        var secretToken = StringExtensions.GenerateRandomString(30);
                        await _telegramClient.SetWebhookAsync($"{_webhookConfiguration.GetHostDomain()}/webhook", !_webhookConfiguration.DontSendCertificate ? sslCertificate?.GetByteArrayAsPem() : null, null, _webhookConfiguration.MaxConnections, null, _webhookConfiguration.DropPendingUpdates, secretToken, _cancellationTokenSource.Token);

                        var builder = WebApplication.CreateSlimBuilder();
                        builder.Logging.ClearProviders();
                        builder.WebHost.ConfigureKestrel(config =>
                        {
                            config.Listen(IPAddress.Any, _webhookConfiguration.HttpsPort, listenOptions =>
                            {
                                listenOptions.UseHttps(sslCertificate!);
                            });
                        });

                        using var webHost = builder.Build();
                        webHost.UseRouting();
                        webHost.MapGet("/webhook", () => "The webhook is online.");
                        webHost.MapPost("/webhook", async (HttpRequest request) =>
                        {
                            if (request.Headers.TryGetValue("X-Telegram-Bot-Api-Secret-Token", out var xTelegramBotApiSecretToken) && xTelegramBotApiSecretToken.ToString() == secretToken)
                            {
                                var update = await JsonSerializer.DeserializeAsync<Update>(request.Body, _jsonSerializerOptions, _cancellationTokenSource.Token);

                                if (update != null)
                                {
                                    IncomingUpdateReceived?.Invoke(this, new IncomingUpdateReceivedEventArgs
                                    {
                                        UpdateReceivedDate = DateTime.UtcNow,
                                        UpdateWay = _getUpdatesWay,
                                        Update = update,
                                    });
                                }

                                return Results.Ok();
                            }
                            else
                            {
                                return Results.Unauthorized();
                            }
                        });

                        try
                        {
                            WebhookIsReady = true;
                            await webHost.RunAsync(_cancellationTokenSource.Token);
                        }
                        catch (TaskCanceledException) { }
                        await _telegramClient.DeleteWebhookAsync(_webhookConfiguration.DropPendingUpdates);
                    }
                }).Start();
            }
        }

        /// <summary>
        /// Stop the thread previously started and dispose all resources used in the thread.
        /// </summary>
        public void StopReceivingUpdates()
        {
            if (_incomingUpdatesHandling)
            {
                _cancellationTokenSource.Cancel();
                _incomingUpdatesHandling = false;
                WebhookIsReady = false;
            }
        }

        /// <summary>
        /// Generate a self signed certificate for the webhook server.
        /// </summary>
        /// <returns>A self signed certificate as <see cref="X509Certificate2"/> object.</returns>
        private X509Certificate2 GenerateSelfSignedCertificate()
        {
            using var rsa = RSA.Create(2048);
            var csr = new CertificateRequest($"cn={_webhookConfiguration!.GetHostDomain()}", rsa, HashAlgorithmName.SHA512, RSASignaturePadding.Pkcs1);
            var san = new SubjectAlternativeNameBuilder();
            san.AddDnsName(_webhookConfiguration!.GetHostDomain());
            csr.CertificateExtensions.Add(san.Build());
            using var certificate = csr.CreateSelfSigned(DateTimeOffset.Now, DateTimeOffset.Now.AddYears(10));
            var pfx = certificate.Export(X509ContentType.Pfx);
            return new X509Certificate2(pfx);
        }

        /// <summary>
        /// Dispose all resources used by the current instance.
        /// </summary>
        public void Dispose()
        {
            StopReceivingUpdates();
            _cancellationTokenSource.Dispose();
            _telegramClient.Dispose();
            GC.SuppressFinalize(this);
        }
    }
}